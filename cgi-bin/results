#!@PERL@ -I@CGIBINDIR@

use CGI qw(:standard);
use Digest::MD5 qw(md5_hex);
use POSIX qw(strftime);
use civs_common;
use DB_File;
use mail;
use beatpath;

use Socket;
use IO::Handle;

$thisurl = $civs_bin_path."/results";

HTML_Header("CIVS Election Results");
use election;

CIVS_Header("Election Results: $title");

CheckElectionID;
CheckStarted;

if ($public ne 'yes') {
    CheckStopped;
}

print h2($title);

print "Election supervisor: $name (<tt>$email_addr</tt>)", br();
if ($public ne 'yes') {
    print "Total authorized voters: $num_auth", br();
}
$num_votes += 0;
print "Actual votes cast: $num_votes", br();
print "Announced end of election: $election_end", br();
if (IsStopped) {
    $close_time = $vdata{'close_time'};
    print "Actual time election ended: $close_time$cr";
} else {
    print "Election has not yet ended.$cr";
}

sub print_nonprop_results {
# print_nonprop_results: print the results of the ordinary
# (nonproportional) beatpath algorithm. Assumes that matrix[j][k]
# contains the ordinary preferences and that closure_matrix[j][j]
# contains the results from the beatpath closure.

    local $j, $jj, $k, $kk;
    print h2("Choices and vote matrix");
    print p("The following matrix shows the number of ballots on
    which choices beat other choices, considered pairwise.");
    print "<table>\n";

    print "<tr><td>&nbsp;</td><td>&nbsp;</td>";
    print "<tr><td>&nbsp;</td><td>&nbsp;</td>";
    for ($jj = 0; $jj < $num_choices; $jj++) {
	$j = $choice_index[$jj];
	if ($proportional ne 'yes') { $j = $jj + 1; }
	print "<th width=20px>".$j.".</th>";
    }
    print "</tr>\n";
    for ($jj = 0; $jj < $num_choices; $jj++) {
	$j1 = $j = $choice_index[$jj];
	if ($proportional ne 'yes') { $j1 = $jj + 1; }
	print "<tr>";
	print "<th align=left>".$j1.". ".$choices[$j]."</th>\n";
	print "<td width=40px>&nbsp;</td>\n";
	for ($kk = 0; $kk < $num_choices; $kk++) {
	    $k = $choice_index[$kk];
	    print "<td class=count>";
	    if ($j == $k) {
		print "- ";
	    } else {
		print $matrix[$j][$k]. " ";
	    }
	    print "</td>";
	}
	print "</tr>\n";
    }
    print "</table>";

    print h2("Beatpath closure matrix");
    print p("
    The following matrix shows the strength of the strongest
    beatpath connecting each pair of choices. Choice 1 is preferred
    to choice 2 if there is a better beatpath leading from 1 to 2
    than any leading from 2 to 1.
    ");
    print "<table>\n";

    print "<tr><td>&nbsp;</td><td>&nbsp;</td>";
    for ($jj = 0; $jj < $num_choices; $jj++) {
	$j1 = $choice_index[$jj];
	if ($proportional ne 'yes') { $j1 = $jj + 1; }
	print "<th width=20px>".$j1.".</th>";
    }
    print "</tr>\n";
    for ($jj = 0; $jj < $num_choices; $jj++) {
	$j1 = $j = $choice_index[$jj];
	if ($proportional ne 'yes') { $j1 = $jj + 1; }
	print "<tr>";
	print "<th align=left>".$j1.". ".$choices[$j]."</th>\n";
	print "<td width=40px>&nbsp;</td>\n";
	for ($kk = 0; $kk < $num_choices; $kk++) {
	    $k = $choice_index[$kk];
	    print "<td class=count>";
	    if ($j == $k) {
		print "-";
	    } else {
		$w = $closure_matrix[$j][$k];
		$l = $closure_matrix[$k][$j];
		if ($w > $l) {
		    print "$w";
		} else {
		    if ($w != 0) { print "$w"; }
		    else { print "."; }
		}
	    }
	    print "</td>";
	}
	print "</tr>\n";
    }
    print "</table>";
}

print h2('Election instructions'), p($description);

if ($proportional ne 'yes') {

# Compute condorcet winner and set up $matrix
$condorcet_winner = -1;
for ($j = 0; $j < $num_choices; $j++) {
    if ($condorcet_winner < 0) { $condorcet_winner = $j; }
    for ($k = 0; $k < $num_choices; $k++) {
	$n = $vdata{"$j.$k"} + 0;
	$matrix[$j][$k] = $n;
	if ($j != $k) {
	    $m = $vdata{"$k.$j"} + 0;
	    if ($n <= $m && $condorcet_winner == $j) {
		$condorcet_winner = -1; # can't be this one
	    }
	}
    }
}

print h2("Condorcet winner");
if ($condorcet_winner >= 0) {
    print p('The Condorcet winner of this election is '.
            strong($choices[$condorcet_winner]));
} else {
    print p('This election had no Condorcet winner.').$cr;
}

print "<pre>";
$beatpath::n = $num_choices;
for ($j = 0; $j < $num_choices; $j++) {
    for ($k = 0; $k < $num_choices; $k++) {
	$beatpath::matrix[$j][$k] = $matrix[$j][$k];
    }
}
&beatpath::rank_candidates();
@result = @beatpath::result;
@closure_matrix = @beatpath::closure_matrix;
print "</pre>";

print h2('Ranking of the choices').$cr;
print p('Winning choices are shown in bold.');

$had_tie = 0;
print "<ol>";
$j = 0;
for ($rank = 0; $rank <= $#result; $rank++) {
    @winner = @{$result[$rank]};
    print "<li>";
    $ranksize = $#winner + 1;
    if ($ranksize > 1) {
	print "Tied:<br>";
    }
    if ($num_seen < $num_winners &&
	$num_seen + $ranksize > $num_winners) {
	$tie = 1;
	$had_tie = 1;
    } else {
	$tie = 0;
    }
    for ($i = 0; $i <= $#winner; $i++) {
	if ($i > 0) { print "<br>"; }
	if ($tie) { print "<font color=red>"; }
	if ($num_seen < $num_winners) {
	    print b($choices[$winner[$i]]);
	} else {
	    print $choices[$winner[$i]];
	}
	$choice_index[$j++] = $winner[$i];
	if ($tie) { print "</font>"; }
    }
    $num_seen += $#winner + 1;
}
print "</ol>";
if ($had_tie) {
    print p("Choices shown in red have tied for being selected. You may wish to select among them randomly.");
}

print_nonprop_results;

} else { # proportional representation 'algorithm'
    print "<h2>Choices</h2>";
    print "<ol start=0>";
    for ($j = 0; $j < $num_choices; $j++) {
	print "<li> ".$choices[$j]."</li>\n";
    }
    print "</ol>";

    print "<h2>Log of search for best result set</h2>";

    @voter_keys = split /[\r\n]+/, $recorded_voters;

print "<pre>";
    if ($num_votes != $#voter_keys + 1) {
	print "Warning: discrepancy between number of
	recorded voters and number of recorded votes!";
    }
# A committee is represented either as an array of integers
# or as a string containing a comma-separated series of integers,
# where those integers are 0-based indices into the @choices array.
# In either case the indices are sorted in ascending order.

    sub kPrefVoter {
# kPrefVoter(f, v, c1, c2) is 1 if voter with index $v
#   has a f-preference for committee c1, 1 if a f-preference
#   for committee c2, and 0 otherwise. Choices are indexed in
#   0..$num_choices-1, voters in 0..$num_votes. c1 and c2 are
#   represented as strings.
	local ($f, $v, $i, $j) = @_;
	$voter_key = $voter_keys[$v];
	$weights = $vdata{$voter_key};
	@weights = split /,/, $weights;

	# print "Voter: $weights considering $i vs. $j\n";

	@c1 = split /,/, $i;
	@c2 = split /,/, $j;

        $sum = 0;
	local $k;
	for ($k = 0; $k < $num_winners; $k++) {
	    @w1[$k] = $weights[$c1[$k]];
	    @w2[$k] = $weights[$c2[$k]];
	}
	@w1 = sort {$a <=> $b} @w1;
	@w2 = sort {$a <=> $b} @w2;
	$sum1 = $sum2 = 0;
	for ($k = 1; $k <= $f; $k++) {
	    $sum1 += $w1[$num_winners - $k];
	    $sum2 += $w2[$num_winners - $k];
	}
	#print "Results before trimming are @w1 and @w2\n";
	#print "Admissible weight totals are $sum1, $sum2\n";
	if ($sum1 > $sum2) { return -1; }
	elsif ($sum1 < $sum2) { return 1; }
	else { return 0; }
    }

    sub kPref {
# kPref(f, c1, c2) sets $ipref to the number of voters with
# a f-preference for committee c1, and $jpref to the number of
# voters with a k-preference for committee c2.  c1 and c2
# are represented as strings. If there is no valid k-preference
# both $ipref and $jpref are set to zero.
	local ($f, $i, $j) = @_;
	#print "Comparing $i to $j at $f-preference. ";
	local ($icnt, $jcnt) = (0,0);
	for ($v = 0; $v < $num_votes; $v++) {
	    if ($f == 0) {
		$c = kPrefVoter($num_winners, $v, $i, $j);
	    } else {
		$c = kPrefVoter($f, $v, $i, $j);
	    }
	    if ($c == -1) { $icnt++; }
	    elsif ($c == 1) { $jcnt++; }
	}
	#print "Simple count yields $icnt, $jcnt\n";
# now throw out invalid f-preferences
	$ipref = $icnt; $jpref = $jcnt;
	if ($f != 0 && $ipref > 0 && ($ipref * ($num_winners+1)/$num_votes) < $f) {
	    #print "Pref 1 is invalid\n";
	    $ipref = 0;
	}
	if ($f != 0 && $jpref > 0 && ($jpref * ($num_winners+1)/$num_votes) < $f) {
	    #print "Pref 2 is invalid\n";
	    $jpref = 0;
	}
    }
    #print "num choices = $num_choices, num winners = $num_winners\n";
    for ($i = 0; $i < $num_winners && $i < $num_choices; $i++) {
	$curr_comm[$i] = $i + $num_choices - $num_winners;
    }

    if ($num_choices > $num_winners) {
# need to throw out some choices...
# XXX This all needs to be reimplemented more carefully

	sub flatten {
	    local $ret = $_[0];
	    for (local $i = 1; $i <= $#_; $i++) {
		$ret .= "," . $_[$i];
	    }
	    return $ret;
	}
	sub compute_in {
	    local $i;
	    for ($i = 0; $i < $num_choices; $i++) { $in{$i} = 0; }
	    for ($i = 0; $i < $num_winners; $i++) { $in{$curr_comm[$i]} = 1; }
	}
	$change = 1;
	$curr_comm = flatten @curr_comm;

# @committee is the array of all visited committees
# %cindex is the index of committees
# $borm[ci1][ci2] is whether comm with index ci2 beats or matches
#    (transitively) the one with ci2

	$iters = 0;
	$full_search = 0;
	$depth = 0;
	$recurse = 1;
	sub dprint {
	    local $msg = $_[0];
	#   for (local $i = 0; $i < $depth; $i++) {
	#     print " ";
	#   }
	    print $msg;
	}

	sub compare_sets {
# compare_sets compares $curr_comm and $new_comm and returns
# 1 if the latter is better.
	    #print "$curr_comm vs. $new_comm (@new_comm): ";
	    local $bestpref = 0;
	    local $bestipref = 0;
	    local $bestjpref = 0;
	    $seen{$curr_comm} = $seen{$new_comm} = 1;
	    for (local $f = 1; $f <= $num_winners; $f++) {
		kPref($f, $curr_comm, $new_comm);
		if ($ipref > $bestpref) { $bestipref = $ipref; }
		if ($jpref > $bestpref) { $bestjpref = $jpref; }
		if ($bestipref > $bestpref) { $bestpref = $bestipref; }
		if ($bestjpref > $bestpref) { $bestpref = $bestjpref; }
	    }
	    # print "best f-preference tally: $bestipref to $bestjpref\n";
	    $tally1{$curr_comm}{$new_comm} = $bestipref;
	    $tally2{$curr_comm}{$new_comm} = $bestjpref;
	    kPref(0, $curr_comm, $new_comm);
	    #print "weak pref: $ipref to $jpref\n";
	    $weaktally1{$curr_comm}{$new_comm} = $ipref;
	    $weaktally2{$curr_comm}{$new_comm} = $jpref;

	    if ($bestjpref > $bestipref) {
		# dprint "$new_comm is preferred to $curr_comm, $bestjpref&ndash;$bestipref\n";
		if ($recurse) {
		    local $save_full_search = $full_search;
		    visit($new_comm);
		    $full_search = $save_full_search;
		}
		return 1;
	    } elsif ($bestjpref == $bestipref) {
		if ($jpref > $ipref
		    # || ($full_search && $jpref == $ipref)
		    ) {
		    # dprint "$new_comm is (weakly) preferred to $curr_comm, $jpref&ndash;$ipref\n";
		    # if ($jpref == $ipref) {
			# dprint "  ...exploring because a cycle has been detected\n";
		    # }
		    if ($recurse) {
			local $save_full_search = $full_search;
			visit($new_comm);
			$full_search = $save_full_search;
		    }
		    return 1;
		}
	    }
	    return 0;
	}
	sub visit {
# XXX this function is a mess.
# visit(c): visit all the committees that beat
#   or match c, where b is a set of committees
#   known to be beaten by c.
# effects: sets $tally1{c1}{c2} to the strong preference for c1 over c2
#          sets $tally2{c1}{c2} to the strong preference for c2 over c1
#          sets $weaktally1{c1}{c2}, $weaktally2{c1}{c2} correspondingly
# requires: $beaten[0..$num_beaten-1] is a set of 
#   committees known to be beaten (or matched) transitively by c
	    $iters++;
	    if ($iters > 500) { return; } # truncate runaway search
	    $depth++;

	    local $curr_comm = $_[0];
	    local @curr_comm = split /,/, $curr_comm;
	    local $cci;
	    local $added = 0;
	    if ($visited{$curr_comm}) {
		if ($full_search) { $depth--; return; }
		if (!$full_search) {
		    dprint "$curr_comm is in a cycle (in the Schwartz set?)\n";
		    $full_search = 1;
		}
	    } else {
		$cci = $#committee + 1;
		$committee[$cci] = $curr_comm;
		$cindex{$curr_comm} = $cci;
		dprint "<b>Considering set: $curr_comm (#$#committee)</b>\n";
		$visited{$curr_comm} = 1;
		$added = 1;
	    }
	    $cci = $cindex{$curr_comm};
	    local $change = 0;
	    local $save_beaten = $beaten[$cci];
	    $beaten[$cci] = 1;
	    for (local $b = 0; $b <= $#committee; $b++) {
# check if any new beaten info has shown up and add to @borm
# if so.
		if ($beaten[$b] && !$borm[$cci][$b]) {
		    $change = 1;
		    $borm[$cci][$b] = 1;
		    # print "$committee[$cci] beats $committee[$b]\n";
		}
	    }
	    if ($change) {
		if (!$added) {
		    dprint "Change to beaten info, revisiting from $curr_comm\n";
		}
		local @new_comm;
		compute_in;
		local $done = 0;
		for (local $i = 0; $i < $num_winners && !$done; $i++) {
# try improving each current member
		    for (local $j = 0; $j < $num_choices && !$done; $j++) {
			@new_comm = @curr_comm;
# try replacing with each choice not currently in the committee
			if (!$in{$j}) {
			    local %save_in = %in;
			    $new_comm[$i] = $j;
			    @new_comm = sort {$a <=> $b} @new_comm ;
			    $new_comm = flatten @new_comm;
			    if (
				!$visited{$new_comm} &&
				compare_sets) {
				# if (!$full_search)
				{ $done = 1; }
# If this committee isn't in the Schwartz set then there is
# no reason to compare to any more committees, because we
# already found at least one that is better than this one.
			    }
			    %in = %save_in;
			}
		    } # for j
		} # for i
		if (!$done && $added) {
		    dprint "$curr_comm beats all nearby unvisited sets\n";
		}
	    } # if change
	    $beaten[$cci] = $save_beaten;
	    # dprint "<b>Done with $curr_comm</b>\n";
	    $depth--;
	}
	visit($curr_comm);

	# $num_unbeaten = $#committee + 1;
	# for ($i = 0; $i <= $#committee; $i++) {
	    # $unbeaten[$i] = 1;
	# }
	# for ($i = 0; $i <= $#committee; $i++) {
	    # for ($j = 0; $j <= $#committee; $j++) {
		# if ($unbeaten[$i] && !$borm[$i][$j]) {
		    # $unbeaten[$i] = 0;
		    # $num_unbeaten--;
		# }
	    # }
	# }
    } # if need to pick winners
    print "</pre>";

    if ($iters > 500) {
	print p(b("Search failed."));
    }
    print '<pre>'.b('Acquiring any missing preference information...').$cr;
    $recurse = 0;
    $divisor = 1;
    while ($divisor < $num_votes) { $divisor *= 10; }
    for (local $j = 0; $j <= $#committee; $j++) {
	for (local $k = 0; $k < $j; $k++) {
	    $curr_comm = $committee[$j];
	    $new_comm = $committee[$k];
	    compare_sets;
	    local $jk = $tally1{$curr_comm}{$new_comm};
	    local $kj = $tally2{$curr_comm}{$new_comm};
	    $beatpath::matrix[$j][$k] = $matrix[$j][$k] = $jk;
	    $beatpath::matrix[$k][$j] = $matrix[$k][$j] = $kj;

		$beatpath::matrix[$j][$k] = $matrix[$j][$k] +=
		    $weaktally1{$curr_comm}{$new_comm}/$divisor;
		$beatpath::matrix[$k][$j] = $matrix[$k][$j] +=
		    $weaktally2{$curr_comm}{$new_comm}/$divisor;
	}
    }
    print '</pre>';
    $beatpath::n = $#committee + 1;
    &beatpath::rank_candidates();
    @result = @beatpath::result;
    @closure_matrix = @beatpath::closure_matrix;
    $j = 0;
    for ($rank = 0; $rank <= $#result; $rank++) {
	@winner = @{$result[$rank]};
	for ($i = 0; $i <= $#winner; $i++) {
	    $choice_index[$j++] = $winner[$i];
	}
    }
    @winner = @{$result[0]};
    $num_unbeaten = $#winner + 1;
    sub printSchwartz {
	print '<table><tr>';
	for ($i = 0; $i < $num_unbeaten; $i++) {
	    print "<td><ol>";
	    @curr_comm = split /,/, $committee[$winner[$i]];
	    for ($j = 0; $j < $num_winners; $j++) {
		print "<li value=\"$curr_comm[$j]\"> $choices[$curr_comm[$j]]$cr";
	    }
	    print "</ol></td>";
	}
	print '</tr></table>';
    }
    if ($num_unbeaten == 1) {
	print h2("Winning set of choices$cr");
	print p("The <a href=\"@CIVSURL@/proportional.html\">apparent</a> Condorcet winner of this election was the following set of choices, which are not listed
	in any particular order:");
	printSchwartz;
    } else {
	print h2("Winning sets of choices$cr");
	print p("There were $num_unbeaten unbeaten sets:$cr");
	printSchwartz;
    }
    print h2('Preference matrix');
    local $combinations = 1;
    local $num_seen = 0;
    for (local $i = 0; $i < $num_winners; $i++) {
	$combinations = $combinations * ($num_choices - $i);
    }
    foreach $k (keys %seen) {
	$num_seen++;
    }
    $num_visited = $#committee + 1;

    print p("There are $combinations possible committees that can be
      formed using $num_winners of the $num_choices choices. Of these,
      $num_visited committees were explored, comparing against 
      $num_seen nearby committees.\n");

    print p('This is the voting preference matrix,
             reporting maximal valid proportional preferences.
	     Fractions indicate nonproportional preferences, which
	     help break ties in proportional preference.');
    print "<table>$cr";
    print "<tr><td>&nbsp;</td><td>&nbsp;</td>";
    for ($j = 0; $j <= $#committee; $j++) {
	print "<th width=20px>".($j+1).".</td>";
    }
    print "</tr>$cr";
    for ($jj = 0; $jj <= $#committee; $jj++) {
	$j = $choice_index[$jj];
	print "<tr>";
	print "<th class=choice>".($jj+1).".&nbsp;(".$committee[$j].")</td>\n";
	print "<td width=40px>&nbsp;</td>\n";
	for ($kk = 0; $kk <= $#committee; $kk++) {
	    $k = $choice_index[$kk];
	    print "<td class=count>";
	    if ($j != $k) {
		print $matrix[$j][$k];
	    } else {
		print '-';
	    }
	    print "</td>";
	}
	print "</tr>\n";
    }
    print "</table>";

    print h2('Beatpath closure matrix');
    print p("The following is the corresponding
	    beatpath matrix. Choice 1 is preferred
	    to choice 2 if there is a better beatpath leading from 1 to 2
	    than any leading from 2 to 1.");

    print "<table>\n";
    print "<tr><td>&nbsp;</td><td>&nbsp;</td>";
    for ($j = 0; $j <= $#committee; $j++) {
	print "<th width=20px>".($j+1).".</th>";
    }
    print "</tr>\n";
    for ($jj = 0; $jj <= $#committee; $jj++) {
	$j = $choice_index[$jj];
	print "<tr>";
	print "<th class=\"choice\">".($jj+1).".&nbsp;(".$committee[$j].")</th>\n";
	print "<td width=40px>&nbsp;</td>\n";
	for ($kk = 0; $kk <= $#committee; $kk++) {
	    $k = $choice_index[$kk];
	    print "<td class=count>";
	    # print "(".$matrix[$j][$k].") ";
	    if ($j == $k) {
		print "-";
	    } else {
		$w = $closure_matrix[$j][$k];
		$l = $closure_matrix[$k][$j];
		if ($w > $l) {
		    print "$w";
		} else {
		    if ($w != 0) { print "$w"; }
		    else { print "."; }
		}
	    }
	    print "</td>";
	}
	print "</tr>\n";
    }
    print "</table>";
    print h2("Pairwise comparison");

    local $max = $num_choices-1;
    print p("You can compare any two sets of choices.
    Just enter the numbers of the choices (from 0 to $max) in each set, with the
    numbers of one set's choices in the left column and the numbers of the other's
    in the right column.");
    print '<form method="POST"
	    action="'.$thisurl.'#comparison"
	    enctype="multipart/form-data"
	    name="CompareSets">';

    print  '<table>';
    if (param('Compare') ne '') {
	$comparison_request = 1;
    }
    @curr_comm = split /,/, $committee[$winner[0]];
    print '<tr><th width=40px>Set 1</th><th width=40px>Set 2</th></tr>';
    for (local $i = 1; $i <= $num_winners; $i++) {
	local $besti = $curr_comm[$i-1];
	local $li, $ri;
	if ($comparison_request) {
	    $li = param("L$i");
	    $ri = param("R$i");
	} else {
	    $li = $curr_comm[$i-1];
	    $ri = "?";
	}
	print "<tr><td><input type=\"text\" name=\"L$i\" size=\"3\" value=\"$li\"></td>\n";
	print "<td><input type=\"text\" name=\"R$i\" size=\"3\" value=\"$ri\"></tr>";
    }
    print '</table>';
    print hidden('id', $election_id);
    print '<input type="submit" value="Compare sets" name="Compare">';
    print '</form>';
    if ($comparison_request) {
	print '<a name="comparison">';
	for (local $i = 1; $i <= $num_winners; $i++) {
	    $curr_comm[$i-1] = param("L$i");
	    $new_comm[$i-1] = param("R$i");
	}
	@curr_comm = sort {$a <=> $b} @curr_comm;
	@new_comm = sort {$a <=> $b} @new_comm;
	$curr_comm = flatten @curr_comm;
	$new_comm = flatten @new_comm;

	print h3("$curr_comm vs. $new_comm:");
	$recurse = 0;
	print '<pre>';
	compare_sets;
	print '</pre>';

	$t1 = $tally1{$curr_comm}{$new_comm};
	$t2 = $tally2{$curr_comm}{$new_comm};
	if ($t1 eq '') {
	    print p('Could not compute preference for some reason.');
	}
	print '<p>Strong (proportional) preference: ';
	if ($t1 > $t2) {
	    print $curr_comm." is preferred by $t1 to $t2";
	} elsif ($t1 < $t2) {
	    print $new_comm." is preferred by $t2 to $t1";
	} else {
	    print "tie, $t1 to $t2\n";
	}
	print '<br>';
	$t1 = $weaktally1{$curr_comm}{$new_comm};
	$t2 = $weaktally2{$curr_comm}{$new_comm};
	print 'Weak (nonproportional) preference: ';
	if ($t1 > $t2) {
	    print $curr_comm." is preferred by $t1 to $t2\n";
	} elsif ($t1 < $t2) {
	    print $new_comm." is preferred by $t2 to $t1\n";
	} else {
	    print "tie, $t1 to $t2\n";
	}
	print '</p>';
	print p(b("Note:").' Nonproportional preferences are relevant only if there is a tie in proportional preferences.');
	print '</a>';
    }
    print "<hr>\n";
    print h2('Nonproportional election');
    print p('The following reports what the results of the election
             would have been if run on single choices, without
	     proportional representation.');

    for (local $j = 0; $j < $num_choices; $j++) {
	$choice_index[$j] = $j;
	for (local $k = 0; $k < $j; $k++) {
	    local $sjk = 0;
	    local $skj = 0;
	    for (local $v = 0; $v < $num_votes; $v++) {
		local $voter_key = $voter_keys[$v];
		local $weights = $vdata{$voter_key};
		local @weights = split /,/, $weights;
		local $wj = $weights[$j];
		local $wk = $weights[$k];
		if ($wj > $wk) { $sjk++; }
		if ($wk > $wj) { $skj++; }
	    }
	    $matrix[$j][$k] = $sjk;
	    $matrix[$k][$j] = $skj;
	}
    }

    print "<pre>";
    $beatpath::n = $num_choices;
    for ($j = 0; $j < $num_choices; $j++) {
	for ($k = 0; $k < $num_choices; $k++) {
	    $beatpath::matrix[$j][$k] = $matrix[$j][$k];
	}
    }
    &beatpath::rank_candidates();
    @result = @beatpath::result;
    @closure_matrix = @beatpath::closure_matrix;
    $j = 0;
    for ($rank = 0; $rank <= $#result; $rank++) {
	@winner = @{$result[$rank]};
	for ($i = 0; $i <= $#winner; $i++) {
	    $choice_index[$j++] = $winner[$i];
	}
    }
    print "</pre>";

    print_nonprop_results;
}


print end_html();

untie %edata;
untie %vdata;

exit 0;
