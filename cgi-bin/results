#!@PERL@ -I@CGIBINDIR@

use CGI qw(:standard);
use Digest::MD5 qw(md5_hex);
use POSIX qw(strftime);
use civs_common;
use DB_File;
use mail;
use beatpath;

use Socket;
use IO::Handle;

$thisurl = $civs_bin_path."/results";

print header(), start_html("Condorcet Internet Voting Service");
use election;

CIVS_Header("Election Results");

CheckElectionID;
CheckStarted;

if ($public ne 'yes') {
    CheckStopped;
}

print h1("$title");

print "Election supervisor: $name (<tt>$email_addr</tt>)", br();
if ($public ne 'yes') {
    print "Total authorized voters: $num_auth", br();
}
$num_votes += 0;
print "Actual votes cast: $num_votes", br();
print "Announced end of election: $election_end", br();
if (IsStopped) {
    $close_time = $vdata{'close_time'};
    print "Actual time election ended: $close_time\n";
} else {
    print "Election has not yet ended.\n";
}


print h2('Election instructions'), p($description);

if ($proportional ne 'yes') {

# Compute condorcet winner and set up $matrix
$condorcet_winner = -1;
for ($j = 0; $j < $num_choices; $j++) {
    if ($condorcet_winner < 0) { $condorcet_winner = $j; }
    for ($k = 0; $k < $num_choices; $k++) {
	$n = $vdata{"$j.$k"} + 0;
	$matrix[$j][$k] = $n;
	if ($j != $k) {
	    $m = $vdata{"$k.$j"} + 0;
	    if ($n <= $m && $condorcet_winner == $j) {
		$condorcet_winner = -1; # can't be this one
	    }
	}
    }
}

print h2("Condorcet winner");
if ($condorcet_winner >= 0) {
    print p("The Condorcet winner of this election is ".
            strong($choices[$condorcet_winner]));
} else {
    print p("This election had no Condorcet winner.\n");
}

print h2("Ranking of the choices\n");
print p("Winning choices are shown in bold.");
print "<pre>";
$beatpath::n = $num_choices;
for ($j = 0; $j < $num_choices; $j++) {
    for ($k = 0; $k < $num_choices; $k++) {
	$beatpath::matrix[$j][$k] = $matrix[$j][$k];
    }
}
&beatpath::rank_candidates();
@result = @beatpath::result;
@closure_matrix = @beatpath::closure_matrix;
print "</pre>";

$num_seen = 0;
$had_tie = 0;
print "<ol>";
$j = 0;
for ($rank = 0; $rank <= $#result; $rank++) {
    @winner = @{$result[$rank]};
    print "<li>";
    $ranksize = $#winner + 1;
    if ($ranksize > 1) {
	print "Tied:<br>";
    }
    if ($num_seen < $num_winners &&
	$num_seen + $ranksize > $num_winners) {
	$tie = 1;
	$had_tie = 1;
    } else {
	$tie = 0;
    }
    for ($i = 0; $i <= $#winner; $i++) {
	if ($i > 0) { print "<br>"; }
	if ($tie) { print "<font color=red>"; }
	if ($num_seen < $num_winners) {
	    print b($choices[$winner[$i]]);
	} else {
	    print $choices[$winner[$i]];
	}
	$choice_index[$j++] = $winner[$i];
	if ($tie) { print "</font>"; }
    }
    $num_seen += $#winner + 1;
}
print "</ol>";
if ($had_tie) {
    print p("Choices shown in red have tied for being selected. You may wish to select among them randomly.");
}


print h2("Choices and vote matrix");
print p("The following matrix shows the number of ballots on
which choices beat other choices, considered pairwise.");
print "<table>\n";

print "<tr><td>&nbsp;</td><td>&nbsp;</td>";
for ($j = 0; $j < $num_choices; $j++) {
    print "<td width=20px>".($j+1).".</td>";
}
print "</tr>\n";
for ($jj = 0; $jj < $num_choices; $jj++) {
    $j = $choice_index[$jj];
    print "<tr>";
    print "<td>".($jj+1).". ".$choices[$j]."</td>\n";
    print "<td width=40px>&nbsp;</td>\n";
    for ($kk = 0; $kk < $num_choices; $kk++) {
	$k = $choice_index[$kk];
	print "<td><tt>";
	if ($j == $k) {
	    print "- ";
	} else {
	    print $matrix[$j][$k]. " ";
	}
	print "</tt></td>";
    }
    print "</tr>\n";
}
print "</table>";

print h2("Beatpath closure matrix");
print p("
The following matrix shows the strength of the strongest
beatpath connecting each pair of choices. Choice 1 is preferred
to choice 2 if there is a better beatpath leading from 1 to 2
than any leading from 2 to 1.
");
print "<table>\n";

print "<tr><td>&nbsp;</td><td>&nbsp;</td>";
for ($j = 0; $j < $num_choices; $j++) {
    print "<td width=20px>".($j+1).".</td>";
}
print "</tr>\n";
for ($jj = 0; $jj < $num_choices; $jj++) {
    $j = $choice_index[$jj];
    print "<tr>";
    print "<td>".($jj+1).". ".$choices[$j]."</td>\n";
    print "<td width=40px>&nbsp;</td>\n";
    for ($kk = 0; $kk < $num_choices; $kk++) {
	$k = $choice_index[$kk];
	print "<td><tt>";
	if ($j == $k) {
	    print "-";
	} else {
	    $w = $closure_matrix[$j][$k];
	    $l = $closure_matrix[$k][$j];
	    if ($w > $l) {
		print "$w";
	    } else {
		if ($w != 0) { print "$w"; }
		else { print "."; }
	    }
	}
	print "</tt></td>";
    }
    print "</tr>\n";
}
print "</table>";

} else { # proportional representation 'algorithm'
    print "<h2>Choices</h2>";
    print "<ol start=0>";
    for ($j = 0; $j < $num_choices; $j++) {
	print "<li> ".$choices[$j]."</li>\n";
    }
    print "</ol>";

    print "<h2>Log of search for best result set</h2>";

    @voter_keys = split /[\r\n]+/, $recorded_voters;

print "<pre>";
    if ($num_votes != $#voter_keys + 1) {
	print "Warning: discrepancy between number of
	recorded voters and number of recorded votes!";
    }
# A committee is represented either as an array of integers
# or as a string containing a comma-separated series of integers,
# where those integers are 0-based indices into the @choices array.
# In either case the indices are sorted in ascending order.

    sub kPrefVoter {
# kPrefVoter(f, v, c1, c2) is 1 if voter with index $v
#   has a f-preference for committee c1, 1 if a f-preference
#   for committee c2, and 0 otherwise. Choices are indexed in
#   0..$num_choices-1, voters in 0..$num_votes. c1 and c2 are
#   represented as strings.
	local ($f, $v, $i, $j) = @_;
	$voter_key = $voter_keys[$v];
	$weights = $vdata{$voter_key};
	@weights = split /,/, $weights;

	# print "Voter: $weights considering $i vs. $j\n";

	@c1 = split /,/, $i;
	@c2 = split /,/, $j;

        $sum = 0;
	local $k;
	for ($k = 0; $k < $num_winners; $k++) {
	    @w1[$k] = $weights[$c1[$k]];
	    @w2[$k] = $weights[$c2[$k]];
	}
	@w1 = sort {$a <=> $b} @w1;
	@w2 = sort {$a <=> $b} @w2;
	$sum1 = $sum2 = 0;
	for ($k = 1; $k <= $f; $k++) {
	    $sum1 += $w1[$num_winners - $k];
	    $sum2 += $w2[$num_winners - $k];
	}
	#print "Results before trimming are @w1 and @w2\n";
	#print "Admissible weight totals are $sum1, $sum2\n";
	if ($sum1 > $sum2) { return -1; }
	elsif ($sum1 < $sum2) { return 1; }
	else { return 0; }
    }

    sub kPref {
# kPref(f, c1, c2) sets $ipref to the number of voters with
# a f-preference for committee c1, and $jpref to the number of
# voters with a k-preference for committee c2.  c1 and c2
# are represented as strings. If there is no valid k-preference
# both $ipref and $jpref are set to zero.
	local ($f, $i, $j) = @_;
	#print "Comparing $i to $j at $f-preference. ";
	local ($icnt, $jcnt) = (0,0);
	for ($v = 0; $v < $num_votes; $v++) {
	    if ($f == 0) {
		$c = kPrefVoter($num_winners, $v, $i, $j);
	    } else {
		$c = kPrefVoter($f, $v, $i, $j);
	    }
	    if ($c == -1) { $icnt++; }
	    elsif ($c == 1) { $jcnt++; }
	}
	#print "Simple count yields $icnt, $jcnt\n";
# now throw out invalid f-preferences
	$ipref = $icnt; $jpref = $jcnt;
	if ($f != 0 && $ipref > 0 && POSIX::ceil($ipref * $num_winners / $num_votes) < $f) {
	    #print "Pref 1 is invalid\n";
	    $ipref = 0;
	}
	if ($f != 0 && $jpref > 0 && POSIX::ceil($jpref * $num_winners / $num_votes) < $f) {
	    #print "Pref 2 is invalid\n";
	    $jpref = 0;
	}
    }
    #print "num choices = $num_choices, num winners = $num_winners\n";
    for ($i = 0; $i < $num_winners && $i < $num_choices; $i++) {
	$curr_comm[$i] = $i + $num_choices - $num_winners;
    }

    if ($num_choices > $num_winners) {
# need to throw out some choices...

	sub flatten {
	    local $ret = $_[0];
	    for (local $i = 1; $i <= $#_; $i++) {
		$ret .= "," . $_[$i];
	    }
	    return $ret;
	}
	sub compute_in {
	    local $i;
	    for ($i = 0; $i < $num_choices; $i++) { $in{$i} = 0; }
	    for ($i = 0; $i < $num_winners; $i++) { $in{$curr_comm[$i]} = 1; }
	}
	$change = 1;
	$curr_comm = flatten @curr_comm;
	$num_beaten = 0;
	$num_visited = 0;
# @committee is the array of all visited committees
# %cindex is the index of committees
# $borm[ci1][ci2] is whether comm with index ci2 beats or matches
#    (transitively) the one with ci2

	$iters = 0;
	$full_search = 0;
	$depth = 0;
	sub dprint {
	    local $msg = $_[0];
	    for (local $i = 0; $i < $depth; $i++) {
		print " ";
	    }
	    print $msg;
	}

	sub compare_sets {
# compare_sets compares $curr_comm and $new_comm and returns
# 1 if the latter is better.
	    #print "Replacing $new_comm[$i] with $j at index $i\n";
	    $new_comm[$i] = $j;
	    @new_comm = sort {$a <=> $b} @new_comm ;
	    $new_comm = flatten @new_comm;
	    # print "$curr_comm vs. $new_comm (@new_comm): ";
	    local $bestpref = 0;
	    local $bestipref = 0;
	    local $bestjpref = 0;
	    for (local $f = 1; $f <= $num_winners; $f++) {
		kPref($f, $curr_comm, $new_comm);
		if ($ipref > $bestpref) { $bestipref = $ipref; }
		if ($jpref > $bestpref) { $bestjpref = $jpref; }
		if ($bestipref > $bestpref) { $bestpref = $bestipref; }
		if ($bestjpref > $bestpref) { $bestpref = $bestjpref; }
	    }
	    #print "best f-preference tally yields $bestipref to $bestjpref\n";
	    if ($bestjpref > $bestipref) {
		dprint "$new_comm is preferred $bestjpref&ndash;$bestipref\n";
		$tally{$curr_comm}{$new_comm} =
		    "$bestipref,$bestjpref";
		local $save_full_search = $full_search;
		visit($new_comm);
		$full_search = $save_full_search;
		return 1;
	    } elsif ($bestjpref == $bestipref) {
		kPref(0, $curr_comm, $new_comm);
		#print "weak pref: $ipref to $jpref\n";
		$weaktally{$curr_comm}{$new_comm} =
		    "$ipref,$jpref";
		if ($jpref > $ipref ||
		    ($full_search && $jpref == $ipref)) {
		    dprint "  $new_comm is (weakly) preferred $bestjpref&ndash;$bestipref\n";
		    if ($jpref == $ipref) {
			dprint "  ...exploring because a cycle has been detected\n";
		    }
		    local $save_full_search = $full_search;
		    visit($new_comm);
		    $full_search = $save_full_search;
		    return 1;
		}
	    }
	    return 0;
	}
	sub visit {
# visit(c): visit all the committees that beat
#   or match c, where b is a set of committees
#   known to be beaten by c
# effects: sets $visited{"$c1|$c2"} to whether c1 transitively beats
#   or matches c2.
# requires: $beaten[0..$num_beaten-1] is a set of 
#   committees known to be beaten (or matched) transitively by c
	    $iters++;
	    if ($iters > 500) { return; } # truncate runaway search
	    $depth++;

	    local $curr_comm = $_[0];
	    local @curr_comm = split /,/, $curr_comm;
	    local $cci;
	    local $added = 0;
	    if ($visited{$curr_comm}) {
		# if ($full_search) { $depth--; return; }
		if (!$full_search) {
		    dprint "$curr_comm is in a cycle (in the Schwartz set?)\n";
		    $full_search = 1;
		}
	    } else {
		$cci = $#committee + 1;
		$committee[$cci] = $curr_comm;
		$cindex{$curr_comm} = $cci;
		dprint "<b>Considering set: $curr_comm (#$#committee)</b>\n";
		$visited{$curr_comm} = 1;
		$added = 1;
	    }
	    $cci = $cindex{$curr_comm};
	    local $change = 0;
	    local $save_beaten = $beaten[$cci];
	    $beaten[$cci] = 1;
	    for (local $b = 0; $b <= $#committee; $b++) {
# check if any new beaten info has shown up and add to @borm
# if so.
		if ($beaten[$b] && !$borm[$cci][$b]) {
		    $change = 1;
		    $borm[$cci][$b] = 1;
		    # print "$committee[$cci] beats $committee[$b]\n";
		}
	    }
	    if ($change) {
		if (!$added) {
		    dprint "Change to beaten info, revisiting from $curr_comm\n";
		}
		local @new_comm;
		compute_in;
		local $done = 0;
		for (local $i = 0; $i < $num_winners && !$done; $i++) {
# try improving each current member
		    for (local $j = 0; $j < $num_choices && !$done; $j++) {
			@new_comm = @curr_comm;
# try replacing with each choice not currently in the committee
			if (!$in{$j}) {
			    local %save_in = %in;
			    if (compare_sets) {
				if (!$full_search) { $done = 1; }
# if this committee isn't in the Schwartz set then there is
# no reason to compare to any more committees, because we
# already found at least one that is better than this one.
			    }
			    %in = %save_in;
			}
		    } # for j
		} # for i
		if (!$done && $added) {
		    dprint "$curr_comm beats all nearby sets\n";
		}
	    } # if change
	    $beaten[$cci] = $save_beaten;
	    dprint "<b>Done with $curr_comm</b>\n";
	    $depth--;
	}
	visit($curr_comm);

	$num_unbeaten = $#committee + 1;
	for ($i = 0; $i <= $#committee; $i++) {
	    $unbeaten[$i] = 1;
	}
	for ($i = 0; $i <= $#committee; $i++) {
	    for ($j = 0; $j <= $#committee; $j++) {
		if ($unbeaten[$i] && !$borm[$i][$j]) {
		    $unbeaten[$i] = 0;
		    $num_unbeaten--;
		}
	    }
	}
    } # if need to pick winners
    print "</pre>";
    print "<h2>Winning set of choices</h2>\n";

    sub printSchwartz {
	print '<table><tr>';
	for ($i = 0; $i <= $#committee; $i++) {
	    if ($unbeaten[$i]) {
		@curr_comm = split /,/, $committee[$i];
		print "<td><ol>";
		for ($j = 0; $j < $num_winners; $j++) {
		    print "<li> ".$choices[$curr_comm[$j]]."\n";
		}
		print "</ol></td>";
	    }
	}
	print '</tr></table>';
    }
    if ($iters > 500) {
	print p(b("Search failed."));
    }
    if ($num_unbeaten == 1) {
	print p("The <a href=\"@CIVSURL@/proportional.html\">apparent</a> Condorcet winner of this election was the following set of choices, which are not listed
	in any particular order:");
	printSchwartz;
    } else {
	print p("There were several unbeaten sets:\n");
	printSchwartz;
	print p("A Condorcet completion algorithm needs to
		be run to choose among them. This is not yet
		implemented\n");
    }
}


print end_html();

untie %edata;
untie %vdata;

exit 0;
